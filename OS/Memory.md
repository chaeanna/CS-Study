# 메모리
현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품이다. 프로그램이 실행되려면 **반드시 메모리에 저장**되어 있어야 한다.

거대한 바이트의 배열이며, 각 바이트에는 주소가 저장된다. CPU는 프로그램 카운터가 지정한 주소에서 명령을 가져와 실행한다.

📌 메모리 존재 이유

CPU에 작업 내용이 전달이 되어야 하는데, 이때 명령어나 데이터는 파일형태로 하드 디스크에 저장되어 있다. 파일의 일부가 버스를 타고 CPU로 올라가고 내려오는 데 이때 버스가 상대적으로 느리다. 그래서 CPU가 빠른 처리를 위해 파일의 일부 내용을 메모리에 올려 놓고 수행하여 컴퓨터의 전체적인 성능을 높인다.


## **메인 메모리(Main Memory)**

현대 컴퓨터 시스템 동작의 주축이다. 프로세스는 실행 중인 프로그램을 말하는 데, 여기서 ‘실행 중’이라는 말은 메인 메모리에 올라갔다는 뜻이다.

RAM(Random Access Memory)라고도 불린다.

## 캐시 메모리(Cache Memory)

주기억장치에서 저장된 내용의 일부를 임시로 저장해두는 기억장치

CPU와 메인메모리 간의 성능 차이에 대한 성능 저하를 줄이기 위한 대안이다. CPU가 어떠한 데이터에 대해 다시 접근할 때, 그 데이터를 캐시 메모리에 저장해놨다면 메인 메모리까지 접근할 필요 없다.

### 캐싱 과정

1. CPU에서 주소 전달, 해당 명령이 캐시 메모리에 존재하는 지 확인
2. 존재 Hit, 존재하지 않다면 Miss
3. 주기억장치로 접근
4. 해당 명령어를 가진 데이터 인출, 캐시에 저장   
→ 캐싱 라인 : 캐시에 데이터를 저장할 대 자료구조를 활용해 묶어서 저장, 캐시에 저장하는 데이터에 데이터의 메모리 주소를 함께 저장하면서 빠르게 정보를 찾을 수 있음(set이나 map)
5. 해당 명령어를 CPU로 전송 

⇒ 적중률 극대화를 위해 **지역성의 원리** 사용

> 지역성

기억 장치 내의 정보를 균일하게 액세스 하는 것이 아니라 한 순간에 특정 부분을 집중적으로 참조

- **시간 지역성** : 최근에 참조된 주소의 내용은 곧 다음에도 참조되는 특성
- **공간 지역성** : 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성
### **MMU (Memory Management Unit, 메모리 관리 장치)**

가상 주소에서 실제 데이터가 담겨 있는 곳에 접근하기 위해 빠른 주소 변환이 필요한데, 이를 MMU가 도와준다.


📌 가상 주소
프로그램 상에서 사용자가 보는 주소 공간.

MMU는 메모리 보호의 역할도 한다. 한 프로세스에게 합법적인 주소 영역을 설정하고, 잘못된 접근이 올 경우 **Trap**을 발생시켜 보호한다.

- base register : 메모리상의 프로세스 시작 주소를 물리 주소로 저장
- limit register : 프로세스의 사이즈를 저장

[프로세스의 접근 가능한 합법적인 메모리 영역(x)]

***base <= x < base+limit***

## 메모리 과할당

실제 메모리 사이즈보다 더 큰 사이즈의 메모리를 프로세스에 할당한 상황이다. 페이징 기법관 같은 메모리 관리 기법은 사용자가 큰 메모리를 사용하는 것처럼 느끼도록 눈속임을 통해 메모리를 할당해준다. 이때 사용되는 것이 가상 메모리 기법이다.

[과할당 상황 시 눈속임 과정을 사용자에게 들킬 상황이 존재]

1. 프로세스 실행 도중 페이지 폴트 발생
2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
3. 메모리의 빈 프레임에 페이지를 올려야 하는데, 모든 메모리가 사용중이라 빈 프레임이 없음

[해결 → 빈 프레임 확보]

1. 메모리에 올라와 있는 한 프로세스를 종료시킴
    → 들킬 가능성 있음
2. **프로세스 하나를 swap out하고, 이 공간을 활용**

## 메모리 할당

운영체제의 영역은 메모리의 낮은 주소에 위치하고 사용자 프로세스 영역은 메모리의 높은 주소 영역을 사용한다. 사용자가 사용하는 프로세스들을 할당 시키는 방법에는 크게 연속적 메모리 할당와 비연속적 메모리 할당 방법이 있다.

### 연속적 메모리 할당

프로세스를 단일 구역에 할당하는 방식으로, 여러 곳에 나눠 할당하지 않고 한 구역에 할당되어 있으므로 연속적이다.

> 비연속 메모리 할당은 프로세스를 여러블럭으로 나누어 메모리의 다른 주소 공간에 배치한다.

![1111](https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/34d5baaf-fb20-48e7-b2cb-867802304a7b)
프로세스의 크기는 제각각으로 프로세스의 할당 & 해제를 반복하다보면 빈 공간이 생긴다. 이를 Hole이라 부르며 관리를 잘 해야한다.

⚠️ **저장 공간에 동적으로 메모리 할당 시 여러 Hole 중 크기 n만큼의 메모리를 어느 Hole에 할당할지에 대한 문제**

→ 3가지 해결 방식 - 메모리 할당 알고리즘: 최초 적합, 최적 적합, 최악 적합
### 1) 최초 적합(first-fit)

구멍들을 탐색하다가 할당할 수 있는 가장 첫 번째 구멍에 할당

### 2) 최적 적합(best-fit)

할당할 수 있는 가장 작은 구멍에 할당

### 3) 최악 적합(worst-fit)

할당할 수 있는 가장 큰 구멍에 할당

문제
![22222](https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/050f4e31-057b-4bb1-b778-5328f6d54f52)

200MB 메모리 할당 요청

1) 최초 적합 : 205MB에 할당, 5MB free frame

2) 최적 적합 : 작은 공간부터 확인, 205MB에 할당

3) 최악 적합 : 큰 공간부터 확인, 300MB에 할당, 100MB free frame

📌 이용 효율과 속도

최초 적합과 최적 적합 모두 시간과 메모리 효율면에서 최악 적합보다 좋다. 최초 적합과 최적 적합을 비교해보면 메모리 효율은 별 차이는 없지만 속도면에선 최초 적합이 더 빠르다.

## 단편화(Fragmentation)

할당 방식을 찾는 이유가 바로 이 단편화때문인데, RAM에서 메모리의 공간이 작은 공간으로 나뉘어 **사용가능한 메모리가 충분히 존재하지만 할당이 불가능한 상태를 메모리 단편화가 발생**했다고 한다.

### 외부 단편화(External Fragmentation)

메모리 할당 알고리즘 모두 외부 단편화를 줄이기 위해 사용한다. 최초 적합과 최적 적합 둘다 어느 공간에 넣든 자투리 공간이 생기기 때문에 외부 단편화가 생긴다. 외부 단편화는 메모리들이 프로세스에게 할당되고 돌아오는 일들이 반복되다 보면, 사용가능한 메모리 공간(Hole)이 너무 작은 조각이 된다. 메모리에 있는 **모든 Hole들을 합치면 사용가능한 공간이지만 여러 곳에 분산되어 사용할 수 없는 문제를 외부 단편화**라고 한다. Fixed Partition Allocation(가변 분할 방식)에서 발생한다. 

해결 : 페이징
![33333](https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/095c9bf5-52f7-461f-9a3e-ca01089077f5)

📌 Fixed Partition Allocation(가변 분할 방식)

- Memory를 똑같은 고정된 크기로 분할
- 분할된 공간이 비게 되면 다른 프로세스가 입력 큐에서 선택되어 빈 공간에 들어옴.

### 내부 단편화(Internal Fragmentation)

내부 단편화는  메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 프로세스에서 사용하는 메모리 공간이 낭비 되는 것을 말한다. Multiple Parition Allocation(다중 분할 방식)에서 발생한다.

해결 : 세그멘테이션
![4444444](https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/792ab0d1-4958-4f63-bc9b-89c78e00e3a1)

📌 Multiple Parition Allocation(다중 분할 방식)

- 메모리에서 어떤 부분이 사용되고 있고 어떤 부분이 사용하지 않은지 파악하는 Table 존재
- 사용 가능한 메모리들을 Hole이라 부른다.
- 프로세스가 메모리의 빈 공간을 찾으면 프로세스를 담을 수 있는 Hole을 찾음.
- 공간이 있으면 할당하고 없으면 공간이 생길때까지 대기 혹은 작은 메모리를 요구하는 프로세스가 있는지 input queue로 돌아가 찾음.
- 동적 메모리 할당 문제 → 메모리 할당받고 끝나면 되돌려주는 과정에서 빈 공간이 생기는 데, 이 공간을 어떻게 다른 process에 할당해 줄지 정해야함. → **메모리 할당 알고리즘**

# 참고문헌
[[공룡책 강의 내용 정리] - 9. Main Memory](https://velog.io/@tjswodud/공룡책-강의-내용-정리-9.-Main-Memory)

[메모리 단편화와 내부 단편화, 외부 단편화 개념 및 차이점?](https://junghyun100.github.io/메모리단편화/)
