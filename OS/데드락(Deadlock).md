# 데드락(Deadlock)
* 두 개 이상의 프로세스나 스레드가 **서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태**
* 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생 함

![image](https://github.com/hyeong-jun-kim/Algorithm_Study/assets/53989167/180a15ba-2dee-418e-844a-a83bddf8dc96)
* 여기서 A 사람은 노트북을 가지고 있지만, 충전기가 없어서 대기중이고
* B 사람은 충전기가 있지만 노트북이 없어서 대기중이다.
* 하지만 둘다 서로 일이 급해서 양보할 생각이 없고, 아무도 자기가 하고자 하는 것을 할 수 없다. 이런 상황이 바로 `교착상태`이다.

### 실제 시스템에서 교착상태 예시
![image](https://github.com/hyeong-jun-kim/Algorithm_Study/assets/53989167/8615e5db-6cae-4ae6-9565-7ab09b18d63f)
* 멤버라는 테이블이 있고, A와 B가 각자 포인트를 가지고 있다. 그리고 동시에 두 트랜잭션이 들어왔다고 가정한다.
* 트랜잭션 1은 멤버 A의 포인트를 빼서 B한테 주는 로직이고, 트랜잭션 2는 B의 포인트에 접근해 lock을 걸고 점유한다.
* 이후 상대방에게 포인트를 추가하기 위해 접근했을 때는 lock이 걸려있는 상태이기 때문에 대기하면서 교착상태에 빠지게 된다.

### 데드락 발생 4가지 조건 (상.점.비.순)
> 이 조건중에 하나라도 조건을 만족시키지 못한다면, 교착 상태가 일어나지 않는다.
* **상호 배제 (Mutual Exclusion)**
    * 여러 프로세스가 동시에 `한 자원`에 접근하지 못하도록한다.
    * 한번에 한 프로세스만이 자원 사용이 가능하다.

* **점유와 대기 (Hold and wait)**
    * 자원을 최소한 하나 보유하고, **다른 프로세스에 할당된 자원을 점유하기 위해 대기**하는 프로세스

* **비선점 조건 (No preemption)**
    * 프로세스에서 자원을 할당받은 후 프로세스가 완료되기 전까지 시스템에서 제어를 뺏을 수 없다.

* **순환대기 조건 (Circular Wait)**
    * 대기 프로세스들이 순환형태로 자원을 대기하고 있어야 한다.
    * 누구 양보없이 서로 나아가려는 방향만 바라보고 계속 기다리는 것이다.

### 데드락을 해결하는 방법
**1. 무시**
* **DeadLock이 드물게 발생하는 곳에서 자주 쓰인다.**
    * 교착 상태가 드물게 발생하는데 해결하기 위해 비용을 지불한다면 더 효율성이 떨어지기 때문이다.
* 만약 교착상태 발생 시 사용자가 프로세스를 죽이거나 시스템 자체를 재부팅해야 한다.

**2. 예방**
- 위에 있는 데드락의 발생조건중 하나라도 발생하지 않게 예방하는 방법이다.
- 프로그램을 개발하는 개발자 역할이다.

```
1. 상호배제 부정
- 읽기와 같은 공유 자원을 사용.

2. 점유와 대기 부정
- 프로세스 대기를 없애기 위해 프로세스가 실행되기 전에 필요한 모든 자원 할당. (자원 낭비)
- 자원을 점유하지 않고 있을 때만 다른 자원을 요청할 수 있도록 함. (기아상태 될 수 있음)

3. 비선점 부정
- 모든 자원에 대한 선점 허용.
- 프로세스가 할당받을 수 없는 자원을 요청하는 경우, 기존에 가지고 있던 자원을 모두 반납하고 새 자원과 이전 자원을 얻기 위해 대기. (자원 낭비)

4. 순환대기 부정
- 자원에 고유한 번호를 할당해서 번호 순서대로 자원을 요구. (자원 낭비)

단점: 교착 상태 발생 조건 중 하나를 제거하는 것은 자원 낭비가 심함
```

**3. 탐지 및 회복**
* 이 방법은 OS가 자원을 달라는대로 주면서 주기적으로 데드락에 빠졌는지 검사한다.
* 만약 데드락에 빠졌다면 바로 전 상태로 회복하면 된다.
* 하지만 오버헤드가 큰 방식이다. 왜냐하면 데드락이 발생한 것을 보고 전 상태로 돌려 줄 때 프로세스/스레드 중에 하나를 죽여서 죽은 놈이 갖고있던 자원을 던져줘야한다. 또 매번 데드락이 발생했는지 체크하는 것도 복잡한 알고리즘을 거친다.

**4. 회피**
위를 보면 deadlock 예방법이 얼마나 비효율적인지 알 수 있다. 이런면을 보충하기 위해 나온 것이 교착상태 회피이다.

> 여기서 중요한 두가지 개념이 있다.
> **Safe State**: 시스템 프로세스들이 요청하는 모든 자원을 Deadlock을 발생시키지 않으면 모두에게 할당해 줄 수 있는 안전상태 safe state에 있다고 한다.
> **Safe Sequence:**: 특정한 순서로 프로세스에 자원할당, 실행, 종료들의 작업을 할 때 deadlock이 발생하지 않는 순서를 의미한다.

### 은행원 알고리즘
다익스트라가 제안한 기법 중 하나로 미리 설정된 **모든 자원들의 할당량을 가지고 시뮬레이션해서 safe-state에 들 수 있는지 검사**한다.
즉, 대기중인 프로세스들의 활동에 대해서 교착상태 가능성을 미리 조사한다.

![image](https://github.com/hyeong-jun-kim/Algorithm_Study/assets/53989167/cc174e3c-fa19-45ee-9f9d-209ef1f23715)
* 은행은 100달러를 가지고 돈을 빌리려는 고객은 3명이다.
* 고객은 필요한 돈이 다 있어야 문제해결 후 상환을 할 수 있다.
* 은행은 우선 각각의 고객에게 20, 30, 40달러를 빌려주고 첫번째 사람은 40, 두번째 사람은 10, 마지막 사람은 20 달러가 더 필요하다.

은행에 남은 돈은 20인데 어떻게 해야 이 세명에게 돈을 다 빌려줄 수 있을까?
우선 **고객 2나 고객 3에게 돈을 먼저 빌려줘야** 그 사람들이 돈을 갚아 나머지 고객들에게 돈을 빌려줄 수 있다.

* 고객 2 - 고객 1 - 고객 3
* 고객 2 - 고객 3 - 고객 1
* 고객 3 - 고객 1 - 고객 2
* 고객 3 - 고객 2 - 고객 1

이렇게 모든 사람들에게 돈을 빌려주고 받을 수 있는 상태를 위에 나온 `안전상태(safe state)`라고 할 수 있다. 또, 이런 순서들이 `안전순서(safe sequence)`라고 한다. 

은행원 알고리즘이 잘 수행되려면 세가지가 필요하다.
* **Max**: 각 고객들이 얼마나 맥시멈으로 돈을 요구할지
* **Allocated**: 각 고객들이 현재 빌린 돈이 얼마인지
* **Available**: 은행이 보유한 돈이 얼마인지 (빌려줄 수 있는 돈)

다음은 프로세스 예시이다.
![image](https://github.com/hyeong-jun-kim/Algorithm_Study/assets/53989167/e6ef491b-667f-48ac-998b-3c929b513efc)
처음에 시스템이 총 12개의 자원이 있다고 가정하면, 여기서 프로세스의 할당된 자원의 합은 5+2+2=9이다. 이제 여기서 safe sequence를 찾아보자.

* 지금 할당가능한 자원은 12-9=3개이다.
* 필요한 자원의 수를 보면 p1만 할당이 가능하다. 3-2 = 1개의 자원이 남는다.
* 실행이 끝난 p1은 자신에게 할당된 모든 자원을 반납하면서 1+4=5개의 자원이 사용 가능하게 되었다.
* 이제 p0에게 자원이 할당가능하게 되었다. (5-5=0)
* p0이 할당받은 자원을 실행 후 반납한다. (0+10=10)
* 이 후 p2에게 자원이 할당 가능하다.

**은행원 알고리즘의 단점**
* 할당할 수 있는 자원의 수가 일정해야한다.
* 사용자 수가 일정해야한다.
* 최대자원 요구량을 미리 알아야한다.
* 프로세스들은 유한한 시간에 자원 반납해야 한다.



## 참고자료
- https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/DeadLock.md
- https://github.com/NKLCWDT/cs/blob/main/Operating%20System/%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C%EC%99%80%20%EA%B8%B0%EC%95%84%EC%83%81%ED%83%9C.md
- https://baebalja.tistory.com/342