# 파일(File)

논리적인 저장 단위로, 관련된 정보 자료들의 집합에 이름을 붙인 것이다. 컴퓨터 시스템의 편리한 사용을 위해 정보 저장의 일괄된 논리적 관점을 제공한다.

📌 파일 속성(File attribute) , 파일의 메타데이터(metadata)

파일을 관리하기 위한 각종 정보이다.

# 파일 시스템

컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록, 유지 및 관리하는 방법이다. 저장매체에 많은 파일이 있으므로, 이러한 **파일을 관리하는 방법**을 말한다.

### 파일 시스템 특징

- 커널 영역에서 동작
- 계층적 디렉터리 구조를 가짐
- 디스크 파티션 별로 하나씩 둘 수 있음.

📌 파티션(Partition)
연속된 저장 공간을 하나 이상의 연속되고 독립적인 영역으로 나누어 사용할 수 있도록 정의한 규약이다.

### 역할

- 파일 관리 : 파일 저장, 참조, 공유
- 보조 저장소 관리 : 저장 공간 할당
- 파일 무결성 메커니즘 : 시스템 파일과 디렉터리의 컨텐츠 보호와 더불어 시스템 권한 보호. 파일이 의도한 정보만 포함하고 있다는 것을 의미한다.
- 접근 방법 제공 : 저장된 데이터에 접근할 수 있는 방법 제공

### 개발 목적

- HDD와 메인 메모리 속도 차 줄이기
- 파일 관리 용이
- HDD의 막대한 용량을 효율적으로 이용

### 주요 파일 시스템

- 윈도우 : FAT, NTFS
- Linux : ext
- Mac OS : HFS, HFS+

### 구조

- 메타 영역 : 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간 정보, 삭제 유무 등 파일의 정보
- 데이터 영역 : 파일의 데이터

## 접근 방법

### 1. 순차 접근(Sequential Access)

가장 단순한 방법이며 파일의 정보가 레코드 순서대로 처리된다.

현재 위치에서 읽거나 쓰면 offset이 자동으로 증가하고, 뒤로 돌아가기 위해선 되감기가 필요하다.
![순차](https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/d84628bd-bfaf-45a2-b9b2-6a805a2e4fb6)

### 2. 직접 접근(Random Access)

파일의 레코드를 임의의 순서로 접근할 수 있다.

읽거나 쓰기의 순서에 제약이 없으며 현재 위치를 유지할 수 있다면 이를 통해 순차 접근 기능도 구현할 수 있다.
<img width="552" alt="직접" src="https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/1f96fe82-1aa5-4f0f-ab21-f8fea614aefc">

### 3. 색인 접근(Index Access)

파일에서 레코드를 찾기 위해 색인을 먼저 찾고 대응되는 포인터를 얻는다.

파일에 직접 접근하여 원하는 데이터를 얻을 수 있다. → 크기가 큰 파일에서 유용
![3](https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/5e179b56-d540-4b49-8be3-482d9c007e89)

## 디렉터리 구조

> 디렉터리(Directory)

파일의 메타데이터 중 일부를 보관하고 있는 일종의 특별한 파일이다.

- 기능
    - 파일 찾기, 생성, 삭제
    - 디렉터리 나열
    - 파일 재명명
    - 파일 시스템 순회
- 디렉터리 구성 조건
    - 디렉터리의 파일 빠르게 탐색 가능
    - 적절한 이름으로 사용자들이 편리하게 사용
    - 파일들을 적절한 분류로 그룹화하여 사용 편리

**디렉터리의 논리적 구조를 정의하는 여러 방법**

### 1. 1단계 디렉터리(Single-Level Directory)

`모든 파일들이 디렉터리 밑에 존재하는 형태`

파일들은 서로 유일한 이름을 가지고 서로 다른 사용자라도 같은 이름을 사용할 수 없다.

![4](https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/6e6065fc-cf52-4205-91be-7a33b08e70f1)

파일이 많아지거나 다수의 사용자가 사용하는 시스템에서는 심각한 제약을 갖는다.

### 2. 2단계 디렉터리(Two-Level Directory)

`각 사용자별로 별도의 디렉터리를 갖는 형태`
![5](https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/6a8edba2-0f2f-41f4-a535-43c9bd40d568)

- UFD : 자신만의 사용자 파일 디렉터리
- MFD : 사용자의 이름과 계정 번호로 색인되어 있는 디렉터리. 각 엔트리는 사용자의 UFD를 가리킨다.

서로 다른 사용자가 같은 이름의 파일을 가질 수 있고 효율적인 탐색이 가능하다.

그룹화가 불가능하고, 다른 사용자의 파일에 접근해야 하는 경우 단점이다.

### 3. 트리 구조 디렉터리(Tree-Structured Directory)

`사용자들이 자신의 서브 디렉터리를 만들어 파일 구성`

하나의 루트 디렉터리를 가지며 모든 파일은 고유한 경로(절대/상대)를 가진다. → 효율적인 탐색, 그룹화 가능

디렉터리도 일종의 파일이므로 일반 파일과 디렉터리로 구분할 필요 있음. → bit = 0 : 일반, bit = 1 : 디렉터리

![6](https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/38c082b7-45bc-41ba-9ac9-b49ec4c5b19d)

### 4. 비순환 그래프 디렉터리(Acyclic-Graph Directory)

`트리 구조의 디렉터리를 일반화한 형태`

디렉터리들이 서브 디렉터리들과 파일을 공유할 수 있도록 한다.

파일 삭제 → 현재 파일을 가리키는 포인터는 대상이 사라짐 🔥 문제

⇒ 참조되는 파일에 참조 계수를 두어, 참조 계수 = 0 : 파일 참조 링크 존재하지 않는다 → 이때 파일을 삭제할 수 있도록 함.

![7](https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/9a7f22e7-8867-4e7e-ba1d-0687e6015222)

### 5. 일반 그래프 디렉터리(General Graph Directory)

`순환을 허용하는 그래프 구조`

순환이 허용되면 무한루프에 빠질 수 있음 🔥 문제

⇒ 하위 디렉터리가 아닌 파일에 대한 링크만 허용하거나 garbage collection을 통해 전체 파일 시스템을 순회하고, 접근 가능한 모든 것을 표시.

![8](https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/e03a3d21-833a-4669-a53e-99b671153b9d)

## 디스크에 파일 시스템 할당

### 1. 연속 할당(Contiguous Allocation)

`파일을 디스크에 연속되게 저장하는 방식`

디렉터리에는 파일이 시작 부분의 위치와 파일의 길이에 대한 정보를 저장하면 전체 탐색 가능하다.

연속적으로 저장되어 있어 한 번의 탐색으로 많은 양을 전송할 수 있고, Random Access가 가능하다.

⇒ 외부 단편화가 발생하며, 파일의 크기를 키우기 어렵다. → 파일 크기 키울 가능성을 고려해 미리 큰 공간을 할당하면 내부 단편화가 발생할 수 있다.

![9](https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/c3299347-2167-40e8-b482-0af612af2301)

### 2. 연결 할당(Linked Allocation)

`연속적으로 할당하지 않고 빈 위치면 자유롭게 할당`

다음 읽어야 할 위치를 연결 리스트처럼 포인터로 가리킨다. → 디렉터리에는 파일이 시작하는 위치와 끝나는 위치만 저장

⇒ 외부 단편화가 발생하지 않으며, Random Access가 불가능하고, 포인터를 위한 공간이 block의 일부가 되어 공간 효율성 ⬇️

![10](https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/2aaaf3b7-7dad-48b2-9f31-6369301e7f98)

해결 : FAT(File-Allocation Table)을 사용해서 포인터를 별도의 위치에 보관하여 신뢰성 문제와 공간 효율성 문제를 해결

## 3. 색인 할당(Indexed Allocation)

`한 블록에 하나의 파일에 대한 데이터의 index들을 모두 저장`

디렉터리에는 해당 블록의 위치만 담음.

⇒ 외부 단편화가 발생하지 않고 Random Access 가능

작은 파일인 경우 블록의 공간 낭비 생기며 너무 큰 파일인 경우 하나의 블록으로 파일 index들을 모두 저장하기엔 부족

![11](https://github.com/hyeong-jun-kim/CS-Study/assets/76768480/97464b6a-4102-4e46-860e-b8571540e44a)


# 참고문헌
[[운영체제(OS)] 11. 파일 시스템(File System)](https://rebro.kr/181)




